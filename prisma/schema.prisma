generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String  @id
  name               String
  preferredFirstName String?
  email              String
  emailVerified      Boolean
  image              String?
  phoneNumber        String?
  gender             String?
  address            String?
  city               String?
  state              String?
  country            String?
  mailingAddress     String?
  mailingCity        String?
  mailingState       String?
  mailingCountry     String?
  bio                String?

  emergencyName         String?
  emergencyRelationship String?
  emergencyLanguage     String?
  emergencyEmail        String?
  emergencyPhoneNumber  String?

  bookingNotifications     Boolean? @default(false)
  listingNotifications     Boolean? @default(false)
  promotionalNotifications Boolean? @default(false)
  accountNotifications     Boolean? @default(false)

  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]
  listing       Listing[]
  booking       Booking[]
  paymentMethod PaymentMethod[]
  savedListing  SavedListing[]
  notification  Notification[]

  role       String?
  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersonatedBy String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Listing {
  id               String  @id @default(uuid())
  title            String?
  slug             String? @unique
  description      String?
  smallDescription String?

  address    String?
  city       String?
  state      String?
  country    String?
  postalCode String?

  propertySize     String?
  bedrooms         Int?
  bathrooms        Int?
  availabilityDate String?

  additionalPolicies String?
  petPolicy          String?
  smokingPolicy      String?
  partyPolicy        String?

  price            String?
  paymentFrequency String?
  securityDeposit  String?
  discount         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Category   Category    @relation(fields: [categoryId], references: [id])
  categoryId String
  amenities  Amenities[] @relation("ListingAmenities")

  photos Photos[]
  User   User     @relation(fields: [userId], references: [id])
  userId String

  status     ListingStatus @default(Draft)
  isApproved Boolean       @default(false)

  booking             Booking[]
  listingBlockedDate  ListingBlockedDate[]
  listingAvailability ListingAvailability[]
  savedListing        SavedListing[]

  @@unique([slug, userId])
}

model PaymentMethod {
  id String @id @default(uuid())

  nameOnCard String
  cardNumber String
  expiryDate String
  cvc        String
  default    Boolean
  cardType   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  User   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
}

model SavedListing {
  id String @id @default(uuid())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  Listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String
}

enum ListingStatus {
  Draft
  Published
  Deleted
  Archived
}

model Notification {
  id String @id @default(uuid())

  User   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  type   NotificationType
  status NotificationStatus @default(Unread)

  title   String
  message String

  color String @default("bg-primary")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum NotificationType {
  Tour
  Save
  Delete
  User
  EditUser
  Security
  Listing
  Booking
  Payment
  Account
  System
  Promotion
  Notification
  Appearance
  Success
  Welcome
  Pending
  Warning
  Archive
}

enum NotificationStatus {
  Unread
  Read
  Archived
}

model Category {
  id          String  @id @default(uuid())
  name        String
  description String?
  icon        String

  listing Listing[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Amenities {
  id          String  @id @default(uuid())
  name        String
  description String?
  icon        String

  listings Listing[] @relation("ListingAmenities")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Photos {
  id    String  @id @default(uuid())
  src   String
  cover Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Listing   Listing? @relation(fields: [listingId], references: [id])
  listingId String?
}

// Tour booking model
model Booking {
  id String @id @default(uuid())

  date     DateTime @db.Date
  timeSlot String

  scheduledAt DateTime

  bookingId String

  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String

  status BookingStatus @default(Pending)

  notes String? // Special requests or notes from user

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, date, timeSlot], name: "unique_listing_datetime")
  @@unique(bookingId)
  // Index for efficient queries
  @@index([listingId, date])
  @@index([userId])
  @@index([status])
  @@index([scheduledAt])
}

enum BookingStatus {
  Pending
  Confirmed
  Cancelled
  Completed
}

// Optional: Model for blocked dates (holidays, maintenance, etc.)
model ListingBlockedDate {
  id String @id @default(uuid())

  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String

  date   DateTime @db.Date
  reason String? // Optional reason for blocking

  // Block specific time slots or entire day
  timeSlots Json? // If null, entire day is blocked

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, date])
}

// Optional: Add a separate model for listing availability rules
model ListingAvailability {
  id String @id @default(uuid())

  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String

  // Day of week (0 = Sunday, 1 = Monday, etc.)
  dayOfWeek Int

  // Available time slots for this day (JSON array of strings)
  timeSlots Json // e.g., ["09:00", "10:00", "14:00", "15:00"]

  // Or alternatively, use start/end times
  startTime String // e.g., "09:00"
  endTime   String // e.g., "17:00"

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, dayOfWeek])
}
