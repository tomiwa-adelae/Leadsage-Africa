generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String  @id
  name               String
  preferredFirstName String?
  email              String
  emailVerified      Boolean
  image              String?
  phoneNumber        String?
  gender             String?
  address            String?
  city               String?
  state              String?
  country            String?
  mailingAddress     String?
  mailingCity        String?
  mailingState       String?
  mailingCountry     String?
  bio                String?

  emergencyName         String?
  emergencyRelationship String?
  emergencyLanguage     String?
  emergencyEmail        String?
  emergencyPhoneNumber  String?

  bookingNotifications     Boolean? @default(false)
  listingNotifications     Boolean? @default(false)
  promotionalNotifications Boolean? @default(false)
  accountNotifications     Boolean? @default(false)

  createdAt       DateTime
  updatedAt       DateTime
  sessions        Session[]
  accounts        Account[]
  listing         Listing[]
  booking         Booking[]
  paymentMethod   PaymentMethod[]
  savedListing    SavedListing[]
  notification    Notification[]
  bookingTimeline BookingTimeline[]
  application     Application[]
  lease           Lease[]
  payment         Payment[]

  onboardingCompleted Boolean? @default(false)

  role       String?
  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersonatedBy String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Listing {
  id               String  @id @default(uuid())
  title            String?
  slug             String? @unique
  description      String?
  smallDescription String?

  address    String?
  city       String?
  state      String?
  country    String?
  postalCode String?

  propertySize     String?
  bedrooms         Int?
  bathrooms        Int?
  availabilityDate String?

  additionalPolicies String?
  petPolicy          String?
  smokingPolicy      String?
  partyPolicy        String?

  price            String?
  paymentFrequency String?
  securityDeposit  String?
  discount         String?

  listingId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Category   Category    @relation(fields: [categoryId], references: [id])
  categoryId String
  amenities  Amenities[] @relation("ListingAmenities")

  photos Photos[]
  User   User     @relation(fields: [userId], references: [id])
  userId String

  status          ListingStatus @default(Draft)
  isApproved      Boolean       @default(false)
  rejectedReasons String?

  booking             Booking[]
  listingBlockedDate  ListingBlockedDate[]
  listingAvailability ListingAvailability[]
  savedListing        SavedListing[]
  application         Application[]
  Lease               Lease[]

  @@unique([slug, userId])
  @@unique([listingId])
}

model PaymentMethod {
  id String @id @default(uuid())

  nameOnCard String
  cardNumber String
  expiryDate String
  cvc        String
  default    Boolean
  cardType   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  User   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
}

model SavedListing {
  id String @id @default(uuid())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  Listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String
}

enum ListingStatus {
  Draft
  Published
  Deleted
  Archived
  Restored
  Rejected
}

model Notification {
  id String @id @default(uuid())

  User   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  type   NotificationType
  status NotificationStatus @default(Unread)

  title   String
  message String

  color String @default("bg-primary")

  isAdmin Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum NotificationType {
  Tour
  Save
  Delete
  User
  EditUser
  Security
  Listing
  Booking
  Payment
  Account
  System
  Promotion
  Notification
  Appearance
  Success
  Welcome
  Pending
  Warning
  Archive
}

enum NotificationStatus {
  Unread
  Read
  Archived
}

model Category {
  id          String  @id @default(uuid())
  name        String
  description String?
  icon        String

  listing Listing[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Amenities {
  id          String  @id @default(uuid())
  name        String
  description String?
  icon        String

  listings Listing[] @relation("ListingAmenities")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Photos {
  id    String  @id @default(uuid())
  src   String
  cover Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Listing   Listing? @relation(fields: [listingId], references: [id])
  listingId String?
}

// Tour booking model
model Booking {
  id String @id @default(uuid())

  date     DateTime @db.Date
  timeSlot String

  scheduledAt DateTime

  bookingId String

  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String

  status BookingStatus @default(Pending)

  bookingTimeline BookingTimeline[]

  notes String? // Special requests or notes from user

  confirmedBy String?
  cancelledBy String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  bookingFeedback BookingFeedback[]

  @@unique([listingId, date, timeSlot], name: "unique_listing_datetime")
  @@unique(bookingId)
  // Index for efficient queries
  @@index([listingId, date])
  @@index([userId])
  @@index([status])
  @@index([scheduledAt])
}

model BookingFeedback {
  id        String  @id @default(uuid())
  Booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  bookingId String

  status  BookingFeedbackStatus
  reasons String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum BookingFeedbackStatus {
  INTERESTED
  NOT_INTERESTED
  NOT_SURE
}

enum BookingStatus {
  Pending
  Confirmed
  Cancelled
  Completed
}

model BookingTimeline {
  id String @id @default(uuid())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Booking   Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  bookingId String

  status BookingStatus @default(Pending)
  User   User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
}

// Optional: Model for blocked dates (holidays, maintenance, etc.)
model ListingBlockedDate {
  id String @id @default(uuid())

  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String

  date   DateTime @db.Date
  reason String? // Optional reason for blocking

  // Block specific time slots or entire day
  timeSlots Json? // If null, entire day is blocked

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, date])
}

// Optional: Add a separate model for listing availability rules
model ListingAvailability {
  id String @id @default(uuid())

  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String

  // Day of week (0 = Sunday, 1 = Monday, etc.)
  dayOfWeek Int

  // Available time slots for this day (JSON array of strings)
  timeSlots Json // e.g., ["09:00", "10:00", "14:00", "15:00"]

  // Or alternatively, use start/end times
  startTime String // e.g., "09:00"
  endTime   String // e.g., "17:00"

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, dayOfWeek])
}

model Application {
  id String @id @default(uuid())

  User      User    @relation(fields: [userId], references: [id])
  userId    String
  Listing   Listing @relation(fields: [listingId], references: [id])
  listingId String

  employmentStatus    String?
  employerName        String?
  employerEmail       String?
  employerPhoneNumber String?
  proofOfEmployment   String?
  monthlyIncome       String?
  jobTitle            String?

  currentLandlordName        String?
  currentLandlordEmail       String?
  currentLandlordPhoneNumber String?
  reasonsForMoving           String?

  govermentID   String?
  proofOfIncome String?

  status          ApplicationStatus @default(PENDING)
  rejectedReasons String?
  additionalInfo  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum ApplicationStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  REJECTED
  DELETED
}

model Lease {
  id String @id @default(uuid())

  startDate  String
  endDate    String
  moveInDate String

  leaseId String

  tenantSignature   String
  landlordSignature String?

  status        LeaseStatus   @default(PENDING)
  depositStatus DepositStatus @default(PENDING) // pending, paid, refunded

  User   User   @relation(fields: [userId], references: [id])
  userId String

  Listing   Listing @relation(fields: [listingId], references: [id])
  listingId String

  payment Payment[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, status], name: "unique_active_lease_per_listing")
}

enum LeaseStatus {
  PENDING
  ACTIVE
  EXPIRED
  RENEWED
  DELETED
  CANCELLED
  TERMINATED
}

enum DepositStatus {
  PENDING
  PAID
  REFUNDED
}

model Payment {
  id String @id @default(uuid())

  Lease   Lease  @relation(fields: [leaseId], references: [id], onDelete: Cascade)
  leaseId String
  User    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  String

  amount String
  type   PaymentType
  status PaymentStatus @default(PENDING)

  reference   String? @unique // Payment gateway reference (e.g. Paystack/Stripe)
  method      String? // e.g. "Card", "Bank Transfer", "Paystack", "Stripe"
  description String? // Optional note for admin/logs
  trxref      String? // Optional note for admin/logs
  transaction String? // Optional note for admin/logs

  paidAt    DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

enum PaymentType {
  RENT
  SECURITY_DEPOSIT
  SERVICE_FEE
  OTHER
}

enum PaymentStatus {
  PENDING // Created but not yet paid
  SUCCESS // Payment successful
  FAILED // Attempt failed
  REFUNDED // Payment refunded
  CANCELLED // Cancelled by user/admin
}

model Contact {
  id String @id @default(uuid())

  fullName    String
  email       String
  phoneNumber String?
  subject     String
  message     String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
