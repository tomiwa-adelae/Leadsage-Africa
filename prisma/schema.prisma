generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean
  image         String?
  phoneNumber   String?
  gender        String?
  address       String?
  city          String?
  state         String?
  country       String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]
  listing       Listing[]
  touring       Touring[]

  role       String?
  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersonatedBy String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Listing {
  id               String  @id @default(uuid())
  title            String?
  slug             String? @unique
  description      String?
  smallDescription String?

  address    String?
  city       String?
  state      String?
  country    String?
  postalCode String?

  propertySize     String?
  bedrooms         Int?
  bathrooms        Int?
  availabilityDate String?

  additionalPolicies String?
  petPolicy          String?
  smokingPolicy      String?
  partyPolicy        String?

  price            String?
  paymentFrequency String?
  securityDeposit  String?
  discount         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Category   Category    @relation(fields: [categoryId], references: [id])
  categoryId String
  amenities  Amenities[] @relation("ListingAmenities")

  photos Photos[]
  User   User     @relation(fields: [userId], references: [id])
  userId String

  status     ListingStatus @default(Draft)
  isApproved Boolean       @default(false)

  touring             Touring[]
  listingBlockedDate  ListingBlockedDate[]
  listingAvailability ListingAvailability[]

  @@unique([slug, userId])
}

enum ListingStatus {
  Draft
  Published
  Deleted
  Archived
}

model Category {
  id          String  @id @default(uuid())
  name        String
  description String?
  icon        String

  listing Listing[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Amenities {
  id          String  @id @default(uuid())
  name        String
  description String?
  icon        String

  listings Listing[] @relation("ListingAmenities")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Photos {
  id    String  @id @default(uuid())
  src   String
  cover Boolean

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Listing   Listing? @relation(fields: [listingId], references: [id])
  listingId String?
}

// Tour booking model
model Touring {
  id String @id @default(uuid())

  date     DateTime @db.Date
  timeSlot String

  scheduledAt DateTime

  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String

  status TouringStatus @default(PENDING)

  notes String? // Special requests or notes from user

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, date, timeSlot], name: "unique_listing_datetime")
  // Index for efficient queries
  @@index([listingId, date])
  @@index([userId])
  @@index([status])
  @@index([scheduledAt])
}

enum TouringStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

// Optional: Model for blocked dates (holidays, maintenance, etc.)
model ListingBlockedDate {
  id String @id @default(uuid())

  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String

  date   DateTime @db.Date
  reason String? // Optional reason for blocking

  // Block specific time slots or entire day
  timeSlots Json? // If null, entire day is blocked

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, date])
}

// Optional: Add a separate model for listing availability rules
model ListingAvailability {
  id String @id @default(uuid())

  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  listingId String

  // Day of week (0 = Sunday, 1 = Monday, etc.)
  dayOfWeek Int

  // Available time slots for this day (JSON array of strings)
  timeSlots Json // e.g., ["09:00", "10:00", "14:00", "15:00"]

  // Or alternatively, use start/end times
  startTime String // e.g., "09:00"
  endTime   String // e.g., "17:00"

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([listingId, dayOfWeek])
}
